<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>éŸ³å£°æ–‡å­—èµ·ã“ã—ãƒ»è¦ç´„ã‚¢ãƒ—ãƒªï¼ˆãƒ­ã‚°è¿½åŠ ç‰ˆï¼‰</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    button { margin: 10px 5px; padding: 10px 20px; font-size: 16px; }
    #status { margin-top: 10px; }
    #result { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>ğŸ™ï¸ éŸ³å£°æ–‡å­—èµ·ã“ã— & è¦ç´„</h1>
  <button id="startBtn">ğŸ”´ éŒ²éŸ³é–‹å§‹</button>
  <button id="stopBtn" disabled>â¹ï¸ éŒ²éŸ³åœæ­¢</button>
  <div id="status">â³ æº–å‚™ä¸­...</div>
  <div id="result"></div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const status = document.getElementById("status");
    const resultDiv = document.getElementById("result");

    let mediaRecorder;
    let transcripts = [];
    let stream;
    let chunkPromises = [];
    let timerInterval;
    let isStopping = false;

    let mimeType = "audio/webm";
    let fileExt = "webm";

    if (MediaRecorder.isTypeSupported("audio/webm")) {
      mimeType = "audio/webm";
      fileExt = "webm";
    } else if (MediaRecorder.isTypeSupported("audio/mp4")) {
      mimeType = "audio/mp4";
      fileExt = "mp4";
    } else {
      alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°éŒ²éŸ³ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
    }

    function log(...args) {
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}]`, ...args);
    }

    async function transcribeBlob(blob, filename) {
      log("ğŸ”„ transcribeBlob é–‹å§‹:", filename);
      const formData = new FormData();
      formData.append("file", blob, filename);
      try {
        const response = await fetch("https://voice-summary-app.onrender.com/transcribe", {
          method: "POST",
          body: formData,
        });
        log("ğŸ“¨ transcribeBlob ãƒ¬ã‚¹ãƒãƒ³ã‚¹å—ä¿¡:", filename, "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:", response.status);
        if (!response.ok) throw new Error("ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼");
        const data = await response.json();
        log("âœ… transcribeBlob JSONå–å¾—æˆåŠŸ:", filename);
        transcripts.push(data.transcription || "(ç©ºã®æ–‡å­—èµ·ã“ã—)");
      } catch (err) {
        console.error("âŒ æ–‡å­—èµ·ã“ã—ã‚¨ãƒ©ãƒ¼:", filename, err);
        transcripts.push("(æ–‡å­—èµ·ã“ã—å¤±æ•—)");
      }
    }

    startBtn.onclick = async () => {
      transcripts = [];
      chunkPromises = [];
      resultDiv.innerHTML = "";
      status.textContent = "ğŸ™ï¸ éŒ²éŸ³ä¸­...";
      isStopping = false;

      log("ğŸ¬ éŒ²éŸ³é–‹å§‹");

      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream, { mimeType });

      mediaRecorder.ondataavailable = (e) => {
        log("ğŸ“¦ ãƒãƒ£ãƒ³ã‚¯å—ä¿¡ size:", e.data.size);
        if (e.data && e.data.size > 1000) {
          const blob = new Blob([e.data], { type: mimeType });
          const filename = `${Date.now()}.${fileExt}`;
          const promise = transcribeBlob(blob, filename);
          chunkPromises.push(promise);
        } else {
          log("âš ï¸ ç„¡åŠ¹ãªãƒãƒ£ãƒ³ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—");
        }
      };

      mediaRecorder.onstop = async () => {
        log("ğŸ›‘ mediaRecorder.onstop ç™ºç«");
        clearInterval(timerInterval);
        status.textContent = "âŒ› æœ€çµ‚ãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­...";

        // æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã‚‚ç¢ºå®Ÿã«å‡¦ç†ã™ã‚‹
        const lastChunkPromise = new Promise((resolve) => {
          const handleLastChunk = (e) => {
            log("ğŸ“¦ æœ€çµ‚ãƒãƒ£ãƒ³ã‚¯å—ä¿¡ size:", e.data.size);
            if (e.data && e.data.size > 1000) {
              const blob = new Blob([e.data], { type: mimeType });
              const filename = `${Date.now()}_last.${fileExt}`;
              const promise = transcribeBlob(blob, filename);
              chunkPromises.push(promise);
              promise.finally(resolve);
            } else {
              log("âš ï¸ æœ€çµ‚ãƒãƒ£ãƒ³ã‚¯ãªã—");
              resolve();
            }
            mediaRecorder.removeEventListener("dataavailable", handleLastChunk);
          };
          mediaRecorder.addEventListener("dataavailable", handleLastChunk);
        });

        mediaRecorder.requestData();
        log("ğŸ“¤ requestData() ç™ºè¡Œ");

        await lastChunkPromise;
        log("âœ… æœ€çµ‚ãƒãƒ£ãƒ³ã‚¯å®Œäº†");
        await Promise.all(chunkPromises);
        log("âœ… ã™ã¹ã¦ã®æ–‡å­—èµ·ã“ã—å®Œäº†");

        const fullText = transcripts.join("\n").trim();
        if (!fullText) {
          log("âš ï¸ å…¨ä½“æ–‡å­—èµ·ã“ã—ãŒç©º");
          status.textContent = "âš ï¸ æ–‡å­—èµ·ã“ã—ãŒç©ºã§ã—ãŸã€‚";
          return;
        }

        log("ğŸ’¡ è¦ç´„ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹");
        status.textContent = "âŒ› è¦ç´„ä¸­...";
        try {
          const response = await fetch("https://voice-summary-app.onrender.com/summarize", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: fullText }),
          });
          log("ğŸ“¨ è¦ç´„ãƒ¬ã‚¹ãƒãƒ³ã‚¹å—ä¿¡", "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:", response.status);
          const data = await response.json();

          resultDiv.innerHTML = `
            <h3>ğŸ“ å…¨ä½“æ–‡å­—èµ·ã“ã—</h3><p>${fullText.replace(/\n/g, "<br>")}</p>
            <h3>âœ¨ è¦ç´„</h3><p>${data.summary}</p>
            <button id="downloadBtn" style="margin-top:10px;">ğŸ“„ PDFã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
          `;
          status.textContent = "âœ… å®Œäº†";

          document.getElementById("downloadBtn").onclick = () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const content = `ã€å…¨ä½“æ–‡å­—èµ·ã“ã—ã€‘\n${fullText}\n\nã€è¦ç´„ã€‘\n${data.summary}`;
            const lines = doc.splitTextToSize(content, 180);
            doc.text(lines, 10, 10);
            doc.save("transcription.pdf");
          };
        } catch (err) {
          console.error("âŒ è¦ç´„ã‚¨ãƒ©ãƒ¼:", err);
          resultDiv.innerHTML = "<p style='color:red;'>è¦ç´„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</p>";
          status.textContent = "âš ï¸ è¦ç´„ã‚¨ãƒ©ãƒ¼";
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorder.start(60000); // 1åˆ†ã”ã¨ã®ãƒãƒ£ãƒ³ã‚¯
      startBtn.disabled = true;
      stopBtn.disabled = false;

      let seconds = 0;
      timerInterval = setInterval(() => {
        seconds++;
        status.textContent = `ğŸ™ï¸ éŒ²éŸ³ä¸­...ï¼ˆ${seconds} ç§’çµŒéï¼‰`;
      }, 1000);
    };

    stopBtn.onclick = () => {
      if (isStopping) return;
      isStopping = true;
      log("ğŸ›‘ stopBtn ã‚¯ãƒªãƒƒã‚¯ â†’ mediaRecorder.stop()");
      status.textContent = "ğŸ›‘ éŒ²éŸ³åœæ­¢ä¸­...";
      mediaRecorder.stop();
    };
  </script>
</body>
</html>
