<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>éŸ³å£°æ–‡å­—èµ·ã“ã—ãƒ»è¦ç´„ã‚¢ãƒ—ãƒª</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    button { margin: 10px 5px; padding: 10px 20px; font-size: 16px; }
    #status { margin-top: 10px; }
    #result { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>ğŸ™ï¸ éŸ³å£°æ–‡å­—èµ·ã“ã— & è¦ç´„</h1>
  <button id="startBtn">ğŸ”´ éŒ²éŸ³é–‹å§‹</button>
  <button id="stopBtn" disabled>â¹ï¸ éŒ²éŸ³åœæ­¢</button>
  <div id="status">â³ æº–å‚™ä¸­...</div>
  <div id="result"></div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const status = document.getElementById("status");
    const resultDiv = document.getElementById("result");

    let mediaRecorder;
    let transcripts = [];
    let stream;
    let chunkPromises = [];
    let timerInterval;
    let isStopping = false;

    let mimeType = "audio/webm";
    let fileExt = "webm";

    if (MediaRecorder.isTypeSupported("audio/webm")) {
      mimeType = "audio/webm";
      fileExt = "webm";
    } else if (MediaRecorder.isTypeSupported("audio/mp4")) {
      mimeType = "audio/mp4";
      fileExt = "mp4";
    } else {
      alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°éŒ²éŸ³ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
    }

    async function transcribeBlob(blob, filename) {
      const formData = new FormData();
      formData.append("file", blob, filename);
      try {
        const response = await fetch("https://voice-summary-app.onrender.com/transcribe", {
          method: "POST",
          body: formData,
        });
        if (!response.ok) throw new Error("ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼");
        const data = await response.json();
        transcripts.push(data.transcription || "(ç©ºã®æ–‡å­—èµ·ã“ã—)");
      } catch (err) {
        console.error("æ–‡å­—èµ·ã“ã—ã‚¨ãƒ©ãƒ¼:", err);
        transcripts.push("(æ–‡å­—èµ·ã“ã—å¤±æ•—)");
      }
    }

    startBtn.onclick = async () => {
      transcripts = [];
      chunkPromises = [];
      resultDiv.innerHTML = "";
      status.textContent = "ğŸ™ï¸ éŒ²éŸ³ä¸­...";
      isStopping = false;

      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream, { mimeType });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 1000) {
          const blob = new Blob([e.data], { type: mimeType });
          const filename = `${Date.now()}.${fileExt}`;
          const promise = transcribeBlob(blob, filename);
          chunkPromises.push(promise);
        } else {
          console.log("ç„¡åŠ¹ãªãƒãƒ£ãƒ³ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ size:", e.data.size);
        }
      };

      mediaRecorder.onstop = async () => {
        clearInterval(timerInterval);
        status.textContent = "âŒ› æœ€çµ‚ãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­...";

        try {
          await Promise.all(chunkPromises);
          const fullText = transcripts.join("\n").trim();
          if (!fullText) {
            status.textContent = "âš ï¸ æ–‡å­—èµ·ã“ã—ãŒç©ºã§ã—ãŸã€‚";
            return;
          }

          status.textContent = "âŒ› è¦ç´„ä¸­...";
          const response = await fetch("https://voice-summary-app.onrender.com/summarize", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: fullText }),
          });
          const data = await response.json();

          resultDiv.innerHTML = `
            <h3>ğŸ“ å…¨ä½“æ–‡å­—èµ·ã“ã—</h3><p>${fullText.replace(/\n/g, "<br>")}</p>
            <h3>âœ¨ è¦ç´„</h3><p>${data.summary}</p>
            <button id="downloadBtn" style="margin-top:10px;">ğŸ“„ PDFã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
          `;
          status.textContent = "âœ… å®Œäº†";

          document.getElementById("downloadBtn").onclick = () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const content = `ã€å…¨ä½“æ–‡å­—èµ·ã“ã—ã€‘\n${fullText}\n\nã€è¦ç´„ã€‘\n${data.summary}`;
            const lines = doc.splitTextToSize(content, 180);
            doc.text(lines, 10, 10);
            doc.save("transcription.pdf");
          };
        } catch (err) {
          console.error("è¦ç´„ã‚¨ãƒ©ãƒ¼:", err);
          resultDiv.innerHTML = "<p style='color:red;'>è¦ç´„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</p>";
          status.textContent = "âš ï¸ è¦ç´„ã‚¨ãƒ©ãƒ¼";
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorder.start(60000); // 1åˆ†ã”ã¨ã«ãƒãƒ£ãƒ³ã‚¯ã‚’ç”Ÿæˆ
      startBtn.disabled = true;
      stopBtn.disabled = false;

      let seconds = 0;
      timerInterval = setInterval(() => {
        seconds++;
        status.textContent = `ğŸ™ï¸ éŒ²éŸ³ä¸­...ï¼ˆ${seconds} ç§’çµŒéï¼‰`;
      }, 1000);
    };

    stopBtn.onclick = () => {
      if (isStopping) return;
      isStopping = true;
      status.textContent = "ğŸ›‘ éŒ²éŸ³åœæ­¢ä¸­...";
      
      // æœ€å¾Œã®ãƒ‡ãƒ¼ã‚¿å–å¾—ã—ã¦ã‹ã‚‰ stop
      mediaRecorder.requestData();

      setTimeout(() => {
        mediaRecorder.stop();
      }, 300); // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ stop
    };
  </script>
</body>
</html>
